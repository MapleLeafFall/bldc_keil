20210306:
1、备忘：
(1)usb插上电脑有不停的叮咚响，以为是接触不良、供电不足，实际不是。
(2)用STLINK Utility界面工具擦除flash（Erase Chip）、下载（Program&Verify）王广乙的VESC_default.bin即可。（甚至不用重新拔插usb）
(3)而原版代码bldc的编译文件BLDC_4_ChibiOS.bin烧进去后连接失败；

2、代码结构分析：
（1）hw_410：
main() ->
	halInit() -> //初始化使能的HAL驱动，和板子专用的功能（实际为空）
        osalInit();
        hal_lld_init(); // /* Platform low level initializations.*/
        palInit(&pal_default_config); //使能GPIOA-G的时钟
        canInit();
        i2cInit();
        icuInit(); //初始化TIM3、TIM9为ICU（Input Capture Unit），作为编码器接口
        spiInit();
        uartInit() ->
            uart_lld_init() -> //USARTv1,指定串口3和6的状态，及其对应的DMA通道
                uartObjectInit(&UARTD3);
                uartObjectInit(&UARTD6);
        usbInit() ->
            usb_lld_init() -> //...\OTGv1\usb_lld.c
                usbObjectInit(&USBD1) //给USB结构体成员清零
        sduInit(); //Serial Driver on USB?（实际为空）
        boardInit(); //（实际为空）
        stInit(); //初始化FOC的TIM2：计数清零、debug时停止输出、分频系数48M/50k(?)
	chSysInit() -> //初始化ChibiOS/RT：必须先关中断，执行完该函数后中断自动使能
        port_init(); //引脚相关初始化：实际为空
        _scheduler_init() -> //调度器初始化：初始化就绪队列（ready_queue）
            queue_init(&ch.rlist.r_queue);
        _vt_init(); //初始化虚拟定时器：空的定时器双向链表
        _tm_init(); //初始化时间测量单元：测量并记录定时器读取函数调用时的跳转耗时
        _core_init(); //内存管理的低级初始化：指定堆的起始、结束地址到全局变量nextmem、endmem
        _heap_init() -> //初始化全局的堆管理结构体default_heap{}：分配函数、空块链表、专用互斥锁
            default_heap.h_provider = chCoreAlloc; //指定堆的分配函数：有互斥锁
            default_heap.h_free.h.u.next = NULL; //指定堆的空块链表：初始为NULL
            default_heap.h_free.h.size = 0; //指定堆的当前空块大小为0
            chMtxObjectInit(&default_heap.h_mtx); //初始化互斥锁中的等待队列为空（双向链表）
        setcurrp(_thread_init(&ch.mainthread, NORMALPRIO)); //内部函数：初始化线程并使其成为当前线程
            _thread_init(&ch.mainthread, NORMALPRIO); //内部函数：初始化ch.mainthread线程的各个成员，并设置其优先级
            currp->p_state = CH_STATE_CURRENT; //系统为运行状态
            chSysEnable(); //使能中断
                __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory"); 
                //设置CPU工作在ARM状态、系统模式、使能IRQ/FIQ中断（https://www.cnblogs.com/lifexy/p/7101686.html）
            chRegSetThreadName((const char *)&ch_debug); //设置当前线程名为"main"；ch_debug还有其他const成员，但这里不使用
            thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL); //创建空闲线程：作为各系统状态下，工作在最低功耗模式的任务，其优先级最低
            chRegSetThreadNameX(tp, "idle"); //设置空闲线程名为"idle"
    chThdSleepMilliseconds(1000) ->
        chThdSleep(MS2ST(msec)) ->
            #define MS2ST(msec) ((systime_t)(((((uint32_t)(msec)) * ((uint32_t)CH_CFG_ST_FREQUENCY)) + 999UL) / 1000UL))
            //单位转换：us转为系统滴答数（10kHz下为100us）
            chSysLock();
            chThdSleepS(time) ->
                chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time) -> //把线程状态设置为CH_STATE_SLEEPING后放入睡眠（队列？），超时时间为time
                    chVTDoSetI(&vt, time, wakeup, currp) -> //初始化虚拟定时器vt的计时时间为time，计时完成后执行wakeup(currp)
                        wakeup(currp) -> //根据currp->p_state添加额外一些处理，然后唤醒线程放入ready_list
                            (void) chSchReadyI(tp);
                    chSchGoSleepS(newstate); //把线程状态设置为CH_STATE_SLEEPING后从ready_list删除，并切换到下一个线程执行
                        ...
                        setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
                        chSysSwitch(currp, otp) ->
                            port_switch(ntp, otp) -> 
                                _port_switch_arm(ntp, otp) -> //chcoreasm.s
                                    stmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}
                                    str     sp, [r1, #12]
                                    ldr     sp, [r0, #12]
                    if (chVTIsArmedI(&vt)) { //检查虚拟定时器有没有成功装载：判断条件为if(vtp->vt_func != NULL)，正常情况应该是wakeup(?)
                        chVTDoResetI(&vt); //如果没有成功装载，则复位该虚拟定时器
                    }
            chSysUnlock();
    hw_init_gpio() -> //hw_410.c：初始化引脚
    conf_general_init() -> //把Flash的sector1/2分别模拟为eeprom page0/1：16kB的0x08004000~0x08007FFFF、16kB的0x08008000~0x0800B000
        EE_Init() ->
            VirtAddVarTab[0~79] = EEPROM_BASE_MCCONF + i = [1000~1079];
            VirtAddVarTab[80~159] = EEPROM_BASE_APPCONF + i = [2000~2079];  //构造虚拟地址映射表（不知道用在哪里？）

            PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS); //0x08004000: 
            switch(PageStatus0)
            {
                default:
                    EE_Format() ->
                        FlashStatus = EE_EraseSectorIfNotEmpty(PAGE0_ID, VOLTAGE_RANGE);
                        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);    //擦除page0，并标记为VALID_PAGE
                        FlashStatus = EE_EraseSectorIfNotEmpty(PAGE1_ID, VOLTAGE_RANGE);        //擦除page1，默认标记为ERASED
            }

    ledpwm_init(); //初始化gamma_table[]数组（LED呼吸灯数组？）
    conf_general_read_mc_configuration(&mcconf); //从e2prom读取电机参数到结构体mcconf
    mc_interface_init(&mcconf) -> //根据电机模式初始化对应的外设、创建线程
      	... //初始化一些电机相关的全局变量
        chThdCreateStatic(..., timer_thread, ...) ->
            static THD_FUNCTION(timer_thread, arg) -> //@mc_interface.c
            //根据Drv8302的fault引脚判断是否停止电机；根据ADC采集的温度和电压值实时更新电机结构体对应的极限值
                for(;;){
                    mc_interface_fault_stop(FAULT_CODE_DRV8302);
                    update_override_limits(&m_conf)                    
                }
    	chThdCreateStatic(..., sample_send_thread, ...) ->
            static THD_FUNCTION(sample_send_thread, arg) ->
                for(;;){
                    chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能是外部控制信号，用来控制数据的发送与否（？）
                    //电机采样全局变量赋值给uint8_t buffer[20];
                    commands_send_samples(buffer, index) ->
                        commands_send_packet(buffer, index) ->
                            send_func(data, len); //函数指针调用发送函数；可能是usb、can、串口、nrf
                }
        switch (m_conf.motor_type) {
            ...
            case MOTOR_TYPE_FOC:
                mcpwm_foc_init(&m_conf) ->
                    filter_create_fir_lowpass((float*)kv_fir_coeffs, ...);
                    filter_create_fir_lowpass((float*)amp_fir_coeffs, ...);
                    filter_create_fir_lowpass((float*)current_fir_coeffs, ...);
                    //分别计算KV、Amplitude、current的FIR滤波器系数                    
                    ... //初始化一些电机相关的全局变量
                    ... //初始化TIM1为PWM：周期为FOC周期m_conf->foc_f_sw（？）
                    ... //初始化ADC1和对应的DMA通道，顺便减去DC偏置量校准一下
                    ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE);
	                nvicEnableVector(ADC_IRQn, 4); //使能ADC的“注入组”转换完成中断
                    ... //初始化TIM8为ADC的触发源：周期为FOC周期m_conf->foc_f_sw（？）
                    ... //初始化TIM12作为Various time measurements（？）
                    chThdCreateStatic(..., timer_thread, ...); //@mcpwm_foc.c
                    //电机状态观测、速度环pid控制电机；仅工作一段时间后退出线程
                    ... //初始化看门狗
                break;
        }
    commands_init() ->
        chThdCreateStatic(..., detect_thread, ...) -> //重点：创建电机参数测量线程
            for(;;) {
                conf_general_detect_motor_param() ->
                    chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能等待上位机控制电机的参数测量，使得该线程可进行可不进行（？）
                    ... //重点函数：测量电机参数（？）
                buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
                buffer_append_int32(send_buffer, (int32_t)(detect_coupling_k * 1000.0), &ind);
                memcpy(send_buffer + ind, detect_hall_table, 8);
                commands_send_packet() 
                //发送三个测量值（？）：detect_cycle_int_limit、detect_coupling_k、detect_hall_table
            }
    comm_usb_init() //初始化usb
    conf_general_read_app_configuration(&appconf); //从e2prom读取电机参数到结构体appconf
	app_init(&appconf);
	timeout_init() ->
        chThdCreateStatic(..., timeout_thread, ...) ->
            static THD_FUNCTION(timeout_thread, arg) {
                if (超时)
                    mc_interface_set_brake_current(timeout_brake_current); //使用指定电流进行刹车
            }
	timeout_configure(appconf.timeout_msec, appconf.timeout_brake_current); //设置刹车电流和超时时间
	comm_can_init(); //初始化can，并创建3个相关的线程
	chThdCreateStatic(..., periodic_thread, ...) ->
        //灯语控制、调试接口数据传输
        //重点函数：电机状态观测
	chThdCreateStatic(..., timer_thread, ....) -> //不同于上面的timer_thread、timeout_thread()线程
        static THD_FUNCTION(timer_thread, arg) {
            for(;;)
                packet_timerfunc() //每1ms检查一次，要使handler_states[i].rx_state=0（？）
        }
    for(;;){}

0309：
1、正常状态下执行完main()后的各个线程：
    (1)chThdCreateStatic(..., _idle_thread, ...)
        //创建空闲线程：作为各系统状态下，工作在最低功耗模式的任务，其优先级最低。
    (2)chThdCreateStatic(..., timer_thread, ...) -> //@mc_interface.c
        //根据Drv8302的fault引脚判断是否停止电机；根据ADC采集的温度和电压值实时更新电机结构体对应的极限值。
    (3)chThdCreateStatic(..., sample_send_thread, ...)
        //等待一个bit0事件：可能是外部控制信号，用来控制电机采集数据的发送与否（？）。
    (4)chThdCreateStatic(..., timer_thread, ...) -> //@mcpwm_foc.c
        //电机状态观测、速度环pid控制电机；仅工作一段时间后退出线程
    (5)chThdCreateStatic(..., detect_thread, ...)
        //chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能等待上位机控制电机的参数测量，使得该线程可进行可不进行（？）
        //重点函数：测量电机参数（？）
    (6)chThdCreateStatic(..., timeout_thread, ...) -> //@timeout.c
        //使用指定电流进行刹车
(7)chThdCreateStatic(..., periodic_thread, ...)
    //灯语控制、调试接口数据传输
    //重点函数：电机状态观测
    (8)chThdCreateStatic(..., timer_thread, ....) -> //@main.c
        //每1ms检查一次，要使handler_states[i].rx_state=0（？）

0310:
1、主要线程有两个：
（1）periodic_thread：
for(;;) {
    //如果电机在正常工作状态：绿灯慢闪
    //如果发生错误（过温、过压、欠压、drv8302错误等）：红、绿灯交替快闪；否则红灯不闪
    
    if (mc_interface_get_state() == MC_STATE_DETECTING) -> //如果电机在参数测量状态：
        commands_send_rotor_pos(mcpwm_get_detect_pos()) ->

}
（2）timer_thread：

2、除了看得见的线程还有中断函数在执行：
mc_interface_init(&mcconf) ->
    mcpwm_foc_init(&m_conf) ->
        ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE) ->
            CH_IRQ_HANDLER(ADC1_2_3_IRQHandler) ->
                mc_interface_adc_inj_int_handler() ->
                    mcpwm_foc_adc_inj_int_handler() ->
                        TIM12->CNT = 0; //清零以统计该函数的耗时：在最后记下TIM12->CNT

                        ADC_curr_norm_value[3]=ADC注入组转换结果，更新三相电流
                        ia=ADC_curr_norm_value[0]转化，单位：*10A
                        ib=ADC_curr_norm_value[1]转化，单位：*10A
                        if (m_samples.measure_inductance_now){
                            //电感测量的状态机：一共10步
                        }

                        if (m_state == MC_STATE_RUNNING) {
                            m_motor_state.i_alpha = ia;
                            m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib; //Clarke变换（幅值不变）：abc静止坐标系->αβ静止坐标系
                            
                            //对当前占空比值进行：取绝对值、低通滤波，然后限幅为-1.0~+1.0（？）
                            if (control_duty) { //如果是在占空比模式、或者柔性刹车（电子制动系统EBS？）进入低速区、或者在速度环下刹车进入低速区：
                                if(当前占空比大于给定占空比、或iq小于下限值) {
                                    //由给定duty=0和当前duty的error进行PID，算出刹车期间的iq给定值（iq_err=(duty_set-duty_now)/Rmin？）
                                    //因为突然把占空比清零比较危险，所以这里需要一个PID（"Truncating the duty cycle here would be dangerous, so run a PID controller"）
                                    //duty理解为“电机施加的电压对母线电压的百分比”
                                }
                                else { //如果当前占空比小于等于给定占空比、且iq大于等于下限值：
                                    //则让给定占空比保存为占空比上限
                                    //设置iq给定电流为电流上限
                                }
                            }else if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE) { //如果是柔性刹车（电子制动系统EBS？）且未进入低速区：
                                    //如果在正转：则iq给定值取反；
                                    //如果已停止：则iq给定值为0；
                                    //没有反转的判断：说明该模式下电机只有单向转
                            }

                            observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
                            m_motor_state.i_alpha, m_motor_state.i_beta, dt, &m_observer_x1,
                            &m_observer_x2, &m_phase_now_observer); //重要函数：非线性观测器，无感状态下观测角度值
                            //foc必须的电角度非线性观测器：（无感时直接用、有感时要校正）
                            //给定一个观测量表达式：x=fn(phase)，然后给出它所满足的微分方程，即为观测器；
                            //该微分方程的输入只需要i、v，不需要speed，所以很方便实用
                            
                            switch (m_conf->foc_sensor_mode) {
                            case FOC_SENSOR_MODE_SENSORLESS:
                                m_motor_state.phase = m_phase_now_observer;
                                //以观测的相位值作为实际值
                                if (duty_abs < m_conf->foc_sl_d_current_duty) {
                                    id_set_tmp = utils_map(duty_abs, 0.0, m_conf->foc_sl_d_current_duty,
                                    fabsf(m_motor_state.iq_target) * m_conf->foc_sl_d_current_factor, 0.0);
                                //为了使观测器在低速时更好地跟踪，需要快速地注入d轴电流（但在具有死区补偿时似乎不是必要的）
                                //把[0.0, foc_sl_d_current_duty]区间的duty_abs映射到[iq_target*foc_sl_d_current_factor, 0.0]得到id_set_tmp（好像只能得到固定的0？）
                            }

                            //先后对iq限幅，确定新的iq目标值：iq限幅、iq和id的矢量和限幅、iq单位转换后限幅（mod_q？）
                            control_current(&m_motor_state, dt); //重要函数：电流环控制
                        }
                        else { //if (m_state != MC_STATE_RUNNING); "when the motor is undriven"
                            float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
                            float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
                            float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2); //测量反电动势Vbemf

                       		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
                        	m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc; //Clarke transform：反电动势不同于电流：没有矢量和为零的关系，所以有3路ADC，变换时都用上

                            utils_fast_sincos_better(m_motor_state.phase, &s, &c);
                            m_motor_state.vd = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
                            m_motor_state.vq = c * m_motor_state.v_beta  - s * m_motor_state.v_alpha; //Park transform

                    		m_motor_state.mod_d = m_motor_state.vd / ((2.0 / 3.0) * m_motor_state.v_bus);
		                    m_motor_state.mod_q = m_motor_state.vq / ((2.0 / 3.0) * m_motor_state.v_bus); //更新调制系数（？）

                       		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
            				m_motor_state.i_alpha, m_motor_state.i_beta, dt, &m_observer_x1,
			            	&m_observer_x2, &m_phase_now_observer); //重要函数：非线性观测器，无感状态下观测角度值

                       		switch (m_conf->foc_sensor_mode) {
                            case FOC_SENSOR_MODE_SENSORLESS:
                                m_motor_state.phase = m_phase_now_observer; //观测器的角度直接作为电机当前状态中的实际角度
                            }
                        }

                        m_motor_state.duty_now = SIGN(m_motor_state.vq) *
			            sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
					    m_motor_state.mod_q * m_motor_state.mod_q) / SQRT3_BY_2; // Calculate duty cycle（？）

                        pll_run(m_motor_state.phase, dt, &m_pll_phase, &m_pll_speed); //重要函数：Run PLL for speed estimation（？）

                        diff_f = utils_angle_difference(angle_now, angle_last);
                        m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
                        //根据p_pid_ang_div参数（应该是虚拟齿轮比），换算得当前角度值：

                        if (m_state == MC_STATE_RUNNING) { //如果电机在工作状态：则执行位置pid控制
                            run_pid_control_pos(m_pos_pid_now, m_pos_pid_set, dt);
                        }

                        mc_interface_mc_timer_isr() -> //重要函数：执行电机的定时器任务：把上面的计算结果应用到电机的控制（？）
                            //控制闪灯频率
                            //检测过压、欠压次数是否大于等于8
                            //执行可能需要的pwm周期后处理函数pwn_done_func()（默认为空）
                            const float current = mc_interface_get_tot_current_filtered(); //获取iq滤波值：带符号，表示拉电流或灌电流；用于求多次平均
                            const float current_in = mc_interface_get_tot_current_in_filtered(); //获取电源输入电流i_bus：正数为耗电、负数为充电；用于求多次平均
                       		abs_current = mcpwm_foc_get_abs_motor_current(); //获取电机电流幅值i_abs：包括id和iq
                    		abs_current_filtered = mcpwm_foc_get_abs_motor_current_filtered(); //获取电机电流幅值滤波值i_abs_filtered：包括id和iq
                            if (m_conf.l_slow_abs_current) {...} //根据l_slow_abs_current选择电机电流的瞬时值/滤波值作为电机过流的判断条件
                            const float f_samp = mc_interface_get_sampling_frequency_now(); //获取采样频率：等于开关频率foc_f_sw的1/2（？）

                            //收到上位机下发的“需要采集数据”命令时：
                            //每进入m_sample_int次会触发一次采集；
                            //每采集m_sample_len次会发送一次信号量通知当前线程；
                            ...
                            m_last_adc_duration_sample = mcpwm_get_last_adc_isr_duration(); //记录上一次的adc转换耗时（？）

                        last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0; //统计该函数的执行时间：单位：秒（？）

0314：
1、下次要做的事：
（1）解决keil工程跑飞的问题：预计16小时；
a.keil工程的cstarup.s使用了ChibiOS官方给旧版ARM编译器RVCT写的文件（E:\cwq_Code\3_guangyi\VESC\ChibiOS_3.0.2\os\common\ports\ARMCMx\compilers\RVCT\cstartup.s）；
b.VESC的makefile调用写给GCC ARM编译器的.s文件，所以要对应GCC的来看怎么改为给ARMCC使用（？）：
    - *.s文件的语法内容在这个文档：D:\gcc-arm-none-eabi-9-2020-q2-update-win32\share\doc\gcc-arm-none-eabi\pdf\as.pdf
    - 中文参考资料：https://www.huaweicloud.com/articles/c22cfc440a163a12f9afe8125da503c5.html
（2）尝试keil自带的rtos调试工具：（EventRecorder、SystemView/SystemAnalyzer）；
（3）不使用keil自带的rtos调试工具，则尝试创建ChibiosStudio工程，来调试代码：预计16小时；

0317：
1、GCC汇编学习：
（1）ldr/str：在寄存器和内存之间传递数值：ldr为“内存传到寄存器”，ltr为“寄存器传到内存”；
（2）mov：把寄存器的数值，或立即数传给寄存器，不能实现内存和寄存器之间的互传；
（3）.type：对已定义的符号进行声明其类型；如.type Reset_Handler, %function表示“把Reset_Handler补充声明为一个汇编函数”；
（4）b：无条件跳转（b=branch，分支到本地标签local label）；可以后接其他字母以表示跳转条件，如bcc=“无进位跳转”，bcs=“有进位跳转”；
（5）定义函数：.section .text.<function>；
（6）定义变量：16bit的data段：.word <var>；
（7）

0402:
1、keil debug跑飞原因定位：
（1）cstartup.s: IMPORT __main=0x080001C0，但实际一跳转就出错？
StFoc keil工程的__main()函数（F417VG）：
0x08000189 0CF8      LSRS          r0,r7,#19
0x0800018B 00D0      LSLS          r0,r2,#3
0x0800018D 7AF0      LDRB          r0,[r6,#0x0B]
0x0800018F 00F8      LSLS          r0,r7,#3
0x08000191 0048      LSLS          r0,r1,#1
0x08000193 4547      CMP           r7,r8
0x08000195 0068      LSLS          r0,r5,#1
0x08000197 0808      LSRS          r0,r1,#0
0x08000199 000F      MOVS          r7,r1
0x0800019B 0620      LSLS          r0,r4,#24
0x0800019D 8048      STRH          r0,[r1,#0x02]
0x0800019F 0647      LSLS          r7,r0,#25
0x080001A1 0048      LSLS          r0,r1,#1
0x080001A3 FE47FEE7  CDP2          P14,0x04,pc,C7,C7,0x07
0x080001A7 FEE7FEE7  CDP2          P14,0x0E,pc,C7,C7,0x07
0x080001AB FEE7FEE7  CDP2          P14,0x0E,pc,C7,C7,0x07
0x080001AF FEE7FEE7  CDP2          P14,0x0E,pc,C7,C7,0x07
0x080001B3 FEE7FEE7  CDP2          P14,0x0E,pc,C7,C7,0x07
0x080001B7 89E7      LDRH          r7,[r4,#0x0E]
0x080001B9 0052      LSLS          r2,r2,#1
0x080001BB 8908      LDRH          r0,[r1,#0x08]
0x080001BD 0001      MOVS          r1,r0
（2）VESC keil工程的__main()函数（F405RG）：
0x080001C1 02F0      LSLS          r0,r6,#11
0x080001C3 00F8      LSLS          r0,r7,#3
0x080001C5 B6F0      DCW           0x0000
0x080001C7 0AF8      LSRS          r0,r7,#11
0x080001C9 90A0      STR           r0,[sp,#0x280]
0x080001CB 00E8      LSLS          r0,r5,#3
0x080001CD 820C      STRH          r4,[r1,#0x10]
0x080001CF 8344      STRH          r4,[r0,#0x1A]
0x080001D1 AA44      ADD           r2,sp,#0x110
0x080001D3 01F1      LSLS          r1,r6,#7
0x080001D5 DA07      BGE           0x080001E7
0x080001D7 0145      LSLS          r5,r0,#5
0x080001D9 00D1      LSLS          r1,r2,#3
0x080001DB ABF0      ADD           r3,sp,#0x3C0
0x080001DD AFF8      ADD           r7,sp,#0x3E0
0x080001DF 09F2      LSRS          r2,r6,#7
0x080001E1 BA0E      REV           r6,r1
0x080001E3 0FE8      LSRS          r0,r5,#31
0x080001E5 1300      ASRS          r0,r0,#12
（3）各段的存放关系：
compiler_user_guide.pdf -> 
    Ch8.4-Default_memory_map ->
        "The processors that are based on Armv6?M and Armv7?M architectures have fixed memory maps.
        Having fixed memory maps makes porting software easier between different systems that are based on
        these processors"
（4）对FPU的入栈命令vpush导致跑飞（chcoreasm_v7m.s）：
应该是FPU初始化没完成。从keil debug的Peripherals->Fault_Reports看到出错时相关的寄存器置位情况：
SCB->CFSR->NOCP = 1;    //The processor has attempted to access a coprocessor - but the processor does not support coprocessor instructions.
SCB->HFSR->FORCED = 1;  //The hard fault handler must read the other fault status registers to find the cause of the fault
SCB->DFSR->HALTED = 1;  //
（5）编译优化即使为-O0，也会在hal_lld_init()函数跑飞：许多语句汇编为DCD 0xFFFFFFFF，导致UNDEFINSTR错误，即“该架构不支持的指令”，原因未知（？），DCD是RVCT的指令，可能是C代码的写法有问题；
（6）第一次跑到这里后会跑飞：（32位的是thumb指令集？）
0x0800612C B510      PUSH          {r4,lr}
    58:   can_lld_init(); 
0x0800612E F000F891  BL.W          can_lld_init (0x08006254)
    59: } 
    60:  
    61: /** 
    62:  * @brief   Initializes the standard part of a @p CANDriver structure. 
    63:  * 
    64:  * @param[out] canp     pointer to the @p CANDriver object 
    65:  * 
    66:  * @init 
    67:  */ 
0x08006132 BD10      POP           {r4,pc}
    68: void canObjectInit(CANDriver *canp) { 
    69:  
0x08006134 B510      PUSH          {r4,lr}
0x08006136 4604      MOV           r4,r0
    70:   canp->state    = CAN_STOP; 
0x08006138 2001      MOVS          r0,#0x01
0x0800613A 7020      STRB          r0,[r4,#0x00]
    71:   canp->config   = NULL; 

2、跑飞原因定位：
（1）需要勾选MicroLib，以配合armcc编译器用于嵌入式系统（因为__main用到C库代码）；
（2）cstartup.s的IF {CPU} = "Cortex-M4.fp"改为IF {CPU} = "Cortex-M4.fp.sp"，才能正确告诉编译器（armcc<=version6.5）需要使能FPU（因为该.s文件是支持更早版本的RVCT编译器的）；
（3）main()->conf_general_init()->EE_Init()->EE_Format()->EE_EraseSectorIfNotEmpty()函数把0x08004000起始的（约）4K e2prom擦除为全0xff导致的：创建了两个大数组来占位这些地址，避免存放正常代码；
（4）

0411：
1、stm32内部的e2prom从哪里来？用flash的sector来模拟的
2、代码已不会跑飞，但不知道跑起来后任务的执行内容，led没有闪？
（1）通过断点看到在mcpwm.c的utils_sys_unlock_cnt()执行完后os就开始了任务调度，没有走完初始化，导致异常；
只有用单步调试走完该函数，才可以继续走到下面，原因未知。
（2）ChibiOS调度器的定时器使用软件定时器，和硬件定时器的关系是：
OSAL_IRQ_HANDLER(SysTick_Handler) -> //定义systick中断函数为一个任务
    OSAL_IRQ_PROLOGUE();
    osalOsTimerHandlerI() ->
        vtDoTickI() ->
            vtlist.vt_systime++;
    OSAL_IRQ_EPILOGUE() ->
        CH_IRQ_EPILOGUE() ->
            PORT_IRQ_EPILOGUE() ->
                _port_irq_epilogue() ->
                    port_lock_from_isr()
                    chSchIsPreemptionRequired() //如果当前任务未执行完自己的时间，则继续执行；除非有更高优先级的任务就绪
                    if (chSchIsPreemptionRequired()) { //根据不同情况决定切换任务的方式
                        ctxp->pc = (regarm_t)_port_switch_from_isr -> //@chcore_v7m.c
                            _port_switch_from_isr -> //@chcoreasm_v7m.s
                                chSchDoReschedule() //任务切换（C函数）
                    }
                    else {
                        ctxp->pc = (regarm_t)_port_exit_from_isr ->
                            ... //任务切换（汇编）
                    }
                    port_unlock_from_isr()
（3）在mcpwm.c的mcpwm_init()下utils_sys_unlock_cnt()前面附近发生了任务抢占（ctxp->pc = (regarm_t)_port_switch_from_isr）；
另外在utils_sys_unlock_cnt()里面也发生了第二次抢占，应该是这个原因导致后续的任务调度异常（？）：没继续往下走完初始化就不断发生任务切换。
（重要：）准备放弃调试：可能要使能CH_DBG_STATISTICS的OS调试宏才能定位问题；从官网看需要配合ChibiosStudio IDE才好用
（http://www.chibios.org/dokuwiki/doku.php?id=chibios:documentation:books:rt:kernel_debug）
