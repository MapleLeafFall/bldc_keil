20210306:
1、备忘：
(1)usb插上电脑有不停的叮咚响，以为是接触不良、供电不足，实际不是。
(2)用STLINK Utility界面工具擦除flash（Erase Chip）、下载（Program&Verify）王广乙的VESC_default.bin即可。（甚至不用重新拔插usb）
(3)而原版代码bldc的编译文件BLDC_4_ChibiOS.bin烧进去后连接失败；

2、代码结构分析：
（1）hw_410：
main() ->
	halInit() -> //初始化使能的HAL驱动，和板子专用的功能（实际为空）
        osalInit();
        hal_lld_init(); // /* Platform low level initializations.*/
        palInit(&pal_default_config); //使能GPIOA-G的时钟
        canInit();
        i2cInit();
        icuInit(); //初始化TIM3、TIM9为ICU（Input Capture Unit），作为编码器接口
        spiInit();
        uartInit() ->
            uart_lld_init() -> //USARTv1,指定串口3和6的状态，及其对应的DMA通道
                uartObjectInit(&UARTD3);
                uartObjectInit(&UARTD6);
        usbInit() ->
            usb_lld_init() -> //...\OTGv1\usb_lld.c
                usbObjectInit(&USBD1) //给USB结构体成员清零
        sduInit(); //Serial Driver on USB?（实际为空）
        boardInit(); //（实际为空）
        stInit(); //初始化FOC的TIM2：计数清零、debug时停止输出、分频系数48M/50k(?)
	chSysInit() -> //初始化ChibiOS/RT：必须先关中断，执行完该函数后中断自动使能
        port_init(); //引脚相关初始化：实际为空
        _scheduler_init() -> //调度器初始化：初始化就绪队列（ready_queue）
            queue_init(&ch.rlist.r_queue);
        _vt_init(); //初始化虚拟定时器：空的定时器双向链表
        _tm_init(); //初始化时间测量单元：测量并记录定时器读取函数调用时的跳转耗时
        _core_init(); //内存管理的低级初始化：指定堆的起始、结束地址到全局变量nextmem、endmem
        _heap_init() -> //初始化全局的堆管理结构体default_heap{}：分配函数、空块链表、专用互斥锁
            default_heap.h_provider = chCoreAlloc; //指定堆的分配函数：有互斥锁
            default_heap.h_free.h.u.next = NULL; //指定堆的空块链表：初始为NULL
            default_heap.h_free.h.size = 0; //指定堆的当前空块大小为0
            chMtxObjectInit(&default_heap.h_mtx); //初始化互斥锁中的等待队列为空（双向链表）
        setcurrp(_thread_init(&ch.mainthread, NORMALPRIO)); //内部函数：初始化线程并使其成为当前线程
            _thread_init(&ch.mainthread, NORMALPRIO); //内部函数：初始化ch.mainthread线程的各个成员，并设置其优先级
            currp->p_state = CH_STATE_CURRENT; //系统为运行状态
            chSysEnable(); //使能中断
                __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory"); 
                //设置CPU工作在ARM状态、系统模式、使能IRQ/FIQ中断（https://www.cnblogs.com/lifexy/p/7101686.html）
            chRegSetThreadName((const char *)&ch_debug); //设置当前线程名为"main"；ch_debug还有其他const成员，但这里不使用
            thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL); //创建空闲线程：作为各系统状态下，工作在最低功耗模式的任务，其优先级最低
            chRegSetThreadNameX(tp, "idle"); //设置空闲线程名为"idle"
    chThdSleepMilliseconds(1000) ->
        chThdSleep(MS2ST(msec)) ->
            #define MS2ST(msec) ((systime_t)(((((uint32_t)(msec)) * ((uint32_t)CH_CFG_ST_FREQUENCY)) + 999UL) / 1000UL))
            //单位转换：us转为系统滴答数（10kHz下为100us）
            chSysLock();
            chThdSleepS(time) ->
                chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time) -> //把线程状态设置为CH_STATE_SLEEPING后放入睡眠（队列？），超时时间为time
                    chVTDoSetI(&vt, time, wakeup, currp) -> //初始化虚拟定时器vt的计时时间为time，计时完成后执行wakeup(currp)
                        wakeup(currp) -> //根据currp->p_state添加额外一些处理，然后唤醒线程放入ready_list
                            (void) chSchReadyI(tp);
                    chSchGoSleepS(newstate); //把线程状态设置为CH_STATE_SLEEPING后从ready_list删除，并切换到下一个线程执行
                        ...
                        setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
                        chSysSwitch(currp, otp) ->
                            port_switch(ntp, otp) -> 
                                _port_switch_arm(ntp, otp) -> //chcoreasm.s
                                    stmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}
                                    str     sp, [r1, #12]
                                    ldr     sp, [r0, #12]
                    if (chVTIsArmedI(&vt)) { //检查虚拟定时器有没有成功装载：判断条件为if(vtp->vt_func != NULL)，正常情况应该是wakeup(?)
                        chVTDoResetI(&vt); //如果没有成功装载，则复位该虚拟定时器
                    }
            chSysUnlock();
    hw_init_gpio() -> //hw_410.c：初始化引脚
    conf_general_init() -> //根据Flash Page0、Page1、e2prom的关系决定如何恢复MCConf和AppConf参数
        ...
    ledpwm_init(); //初始化gamma_table[]数组（LED呼吸灯数组？）
    conf_general_read_mc_configuration(&mcconf); //从e2prom读取电机参数到结构体mcconf
    mc_interface_init(&mcconf) -> //根据电机模式初始化对应的外设、创建线程
      	... //初始化一些电机相关的全局变量
        chThdCreateStatic(..., timer_thread, ...) ->
            static THD_FUNCTION(timer_thread, arg) -> //@mc_interface.c
            //根据Drv8302的fault引脚判断是否停止电机；根据ADC采集的温度和电压值实时更新电机结构体对应的极限值
                for(;;){
                    mc_interface_fault_stop(FAULT_CODE_DRV8302);
                    update_override_limits(&m_conf)                    
                }
    	chThdCreateStatic(..., sample_send_thread, ...) ->
            static THD_FUNCTION(sample_send_thread, arg) ->
                for(;;){
                    chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能是外部控制信号，用来控制数据的发送与否（？）
                    //电机采样全局变量赋值给uint8_t buffer[20];
                    commands_send_samples(buffer, index) ->
                        commands_send_packet(buffer, index) ->
                            send_func(data, len); //函数指针调用发送函数；可能是usb、can、串口、nrf
                }
        switch (m_conf.motor_type) {
            ...
            case MOTOR_TYPE_FOC:
                mcpwm_foc_init(&m_conf) ->
                    filter_create_fir_lowpass((float*)kv_fir_coeffs, ...);
                    filter_create_fir_lowpass((float*)amp_fir_coeffs, ...);
                    filter_create_fir_lowpass((float*)current_fir_coeffs, ...);
                    //分别计算KV、Amplitude、current的FIR滤波器系数                    
                    ... //初始化一些电机相关的全局变量
                    ... //初始化TIM1为PWM：周期为FOC周期m_conf->foc_f_sw（？）
                    ... //初始化ADC1和对应的DMA通道，顺便减去DC偏置量校准一下
                    ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE);
	                nvicEnableVector(ADC_IRQn, 4); //使能ADC的“注入组”转换完成中断
                    ... //初始化TIM8为ADC的触发源：周期为FOC周期m_conf->foc_f_sw（？）
                    ... //初始化TIM12作为Various time measurements（？）
                    chThdCreateStatic(..., timer_thread, ...); //@mcpwm_foc.c
                    //电机状态观测、速度环pid控制电机；仅工作一段时间后退出线程
                    ... //初始化看门狗
                break;
        }
    commands_init() ->
        chThdCreateStatic(..., detect_thread, ...) -> //重点：创建电机参数测量线程
            for(;;) {
                conf_general_detect_motor_param() ->
                    chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能等待上位机控制电机的参数测量，使得该线程可进行可不进行（？）
                    ... //重点函数：测量电机参数（？）
                buffer_append_int32(send_buffer, (int32_t)(detect_cycle_int_limit * 1000.0), &ind);
                buffer_append_int32(send_buffer, (int32_t)(detect_coupling_k * 1000.0), &ind);
                memcpy(send_buffer + ind, detect_hall_table, 8);
                commands_send_packet() 
                //发送三个测量值（？）：detect_cycle_int_limit、detect_coupling_k、detect_hall_table
            }
    comm_usb_init() //初始化usb
    conf_general_read_app_configuration(&appconf); //从e2prom读取电机参数到结构体appconf
	app_init(&appconf);
	timeout_init() ->
        chThdCreateStatic(..., timeout_thread, ...) ->
            static THD_FUNCTION(timeout_thread, arg) {
                if (超时)
                    mc_interface_set_brake_current(timeout_brake_current); //使用指定电流进行刹车
            }
	timeout_configure(appconf.timeout_msec, appconf.timeout_brake_current); //设置刹车电流和超时时间
	comm_can_init(); //初始化can，并创建3个相关的线程
	chThdCreateStatic(..., periodic_thread, ...) ->
        //灯语控制、调试接口数据传输
        //重点函数：电机状态观测
	chThdCreateStatic(..., timer_thread, ....) -> //不同于上面的timer_thread、timeout_thread()线程
        static THD_FUNCTION(timer_thread, arg) {
            for(;;)
                packet_timerfunc() //每1ms检查一次，要使handler_states[i].rx_state=0（？）
        }
    for(;;){}

0309：
1、正常状态下执行完main()后的各个线程：
    (1)chThdCreateStatic(..., _idle_thread, ...)
        //创建空闲线程：作为各系统状态下，工作在最低功耗模式的任务，其优先级最低。
    (2)chThdCreateStatic(..., timer_thread, ...) -> //@mc_interface.c
        //根据Drv8302的fault引脚判断是否停止电机；根据ADC采集的温度和电压值实时更新电机结构体对应的极限值。
    (3)chThdCreateStatic(..., sample_send_thread, ...)
        //等待一个bit0事件：可能是外部控制信号，用来控制电机采集数据的发送与否（？）。
    (4)chThdCreateStatic(..., timer_thread, ...) -> //@mcpwm_foc.c
        //电机状态观测、速度环pid控制电机；仅工作一段时间后退出线程
    (5)chThdCreateStatic(..., detect_thread, ...)
        //chEvtWaitAny((eventmask_t) 1); //等待一个bit0事件：可能等待上位机控制电机的参数测量，使得该线程可进行可不进行（？）
        //重点函数：测量电机参数（？）
    (6)chThdCreateStatic(..., timeout_thread, ...) -> //@timeout.c
        //使用指定电流进行刹车
(7)chThdCreateStatic(..., periodic_thread, ...)
    //灯语控制、调试接口数据传输
    //重点函数：电机状态观测
    (8)chThdCreateStatic(..., timer_thread, ....) -> //@main.c
        //每1ms检查一次，要使handler_states[i].rx_state=0（？）

0310:
1、主要线程有两个：
（1）periodic_thread：
for(;;) {
    //如果电机在正常工作状态：绿灯慢闪
    //如果发生错误（过温、过压、欠压、drv8302错误等）：红、绿灯交替快闪；否则红灯不闪
    
    if (mc_interface_get_state() == MC_STATE_DETECTING) -> //如果电机在参数测量状态：
        commands_send_rotor_pos(mcpwm_get_detect_pos()) ->

}
（2）timer_thread：

2、除了看得见的线程还有中断函数在执行：
mc_interface_init(&mcconf) ->
    mcpwm_foc_init(&m_conf) ->
        ADC_ITConfig(ADC1, ADC_IT_JEOC, ENABLE) ->
            CH_IRQ_HANDLER(ADC1_2_3_IRQHandler) ->
                mc_interface_adc_inj_int_handler() ->
                    mcpwm_foc_adc_inj_int_handler() ->
                        TIM12->CNT = 0; //清零以统计该函数的耗时：在最后记下TIM12->CNT

                        ADC_curr_norm_value[3]=ADC注入组转换结果，更新三相电流
                        ia=ADC_curr_norm_value[0]转化，单位：*10A
                        ib=ADC_curr_norm_value[1]转化，单位：*10A
                        if (m_samples.measure_inductance_now){
                            //电感测量的状态机：一共10步
                        }

                        if (m_state == MC_STATE_RUNNING) {
                            m_motor_state.i_alpha = ia;
                            m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib; //Clarke变换（幅值不变）：abc静止坐标系->αβ静止坐标系
                            
                            //对当前占空比值进行：取绝对值、低通滤波，然后限幅为-1.0~+1.0（？）
                            if (control_duty) { //如果是在占空比模式、或者柔性刹车（电子制动系统EBS？）进入低速区、或者在速度环下刹车进入低速区：
                                if(当前占空比大于给定占空比、或iq小于下限值) {
                                    //由给定duty=0和当前duty的error进行PID，算出刹车期间的iq给定值（iq_err=(duty_set-duty_now)/Rmin？）
                                    //因为突然把占空比清零比较危险，所以这里需要一个PID（"Truncating the duty cycle here would be dangerous, so run a PID controller"）
                                    //duty理解为“电机施加的电压对母线电压的百分比”
                                }
                                else { //如果当前占空比小于等于给定占空比、且iq大于等于下限值：
                                    //则让给定占空比保存为占空比上限
                                    //设置iq给定电流为电流上限
                                }
                            }else if (m_control_mode == CONTROL_MODE_CURRENT_BRAKE) { //如果是柔性刹车（电子制动系统EBS？）且未进入低速区：
                                    //如果在正转：则iq给定值取反；
                                    //如果已停止：则iq给定值为0；
                                    //没有反转的判断：说明该模式下电机只有单向转
                            }

                            observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
                            m_motor_state.i_alpha, m_motor_state.i_beta, dt, &m_observer_x1,
                            &m_observer_x2, &m_phase_now_observer); //重要函数：非线性观测器，无感状态下观测角度值
                            //foc必须的电角度非线性观测器：（无感时直接用、有感时要校正）
                            //给定一个观测量表达式：x=fn(phase)，然后给出它所满足的微分方程，即为观测器；
                            //该微分方程的输入只需要i、v，不需要speed，所以很方便实用
                            
                            switch (m_conf->foc_sensor_mode) {
                            case FOC_SENSOR_MODE_SENSORLESS:
                                m_motor_state.phase = m_phase_now_observer;
                                //以观测的相位值作为实际值
                                if (duty_abs < m_conf->foc_sl_d_current_duty) {
                                    id_set_tmp = utils_map(duty_abs, 0.0, m_conf->foc_sl_d_current_duty,
                                    fabsf(m_motor_state.iq_target) * m_conf->foc_sl_d_current_factor, 0.0);
                                //为了使观测器在低速时更好地跟踪，需要快速地注入d轴电流（但在具有死区补偿时似乎不是必要的）
                                //把[0.0, foc_sl_d_current_duty]区间的duty_abs映射到[iq_target*foc_sl_d_current_factor, 0.0]得到id_set_tmp（好像只能得到固定的0？）
                            }

                            //先后对iq限幅，确定新的iq目标值：iq限幅、iq和id的矢量和限幅、iq单位转换后限幅（mod_q？）
                            control_current(&m_motor_state, dt); //重要函数：电流环控制
                        }
                        else { //if (m_state != MC_STATE_RUNNING); "when the motor is undriven"
                            float Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);
                            float Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);
                            float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2); //测量反电动势Vbemf

                       		m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
                        	m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc; //Clarke transform：反电动势不同于电流：没有矢量和为零的关系，所以有3路ADC，变换时都用上

                            utils_fast_sincos_better(m_motor_state.phase, &s, &c);
                            m_motor_state.vd = c * m_motor_state.v_alpha + s * m_motor_state.v_beta;
                            m_motor_state.vq = c * m_motor_state.v_beta  - s * m_motor_state.v_alpha; //Park transform

                    		m_motor_state.mod_d = m_motor_state.vd / ((2.0 / 3.0) * m_motor_state.v_bus);
		                    m_motor_state.mod_q = m_motor_state.vq / ((2.0 / 3.0) * m_motor_state.v_bus); //更新调制系数（？）

                       		observer_update(m_motor_state.v_alpha, m_motor_state.v_beta,
            				m_motor_state.i_alpha, m_motor_state.i_beta, dt, &m_observer_x1,
			            	&m_observer_x2, &m_phase_now_observer); //重要函数：非线性观测器，无感状态下观测角度值

                       		switch (m_conf->foc_sensor_mode) {
                            case FOC_SENSOR_MODE_SENSORLESS:
                                m_motor_state.phase = m_phase_now_observer; //观测器的角度直接作为电机当前状态中的实际角度
                            }
                        }

                        m_motor_state.duty_now = SIGN(m_motor_state.vq) *
			            sqrtf(m_motor_state.mod_d * m_motor_state.mod_d +
					    m_motor_state.mod_q * m_motor_state.mod_q) / SQRT3_BY_2; // Calculate duty cycle（？）

                        pll_run(m_motor_state.phase, dt, &m_pll_phase, &m_pll_speed); //重要函数：Run PLL for speed estimation（？）

                        diff_f = utils_angle_difference(angle_now, angle_last);
                        m_pos_pid_now += diff_f / m_conf->p_pid_ang_div;
                        //根据p_pid_ang_div参数（应该是虚拟齿轮比），换算得当前角度值：

                        if (m_state == MC_STATE_RUNNING) { //如果电机在工作状态：则执行位置pid控制
                            run_pid_control_pos(m_pos_pid_now, m_pos_pid_set, dt);
                        }

                        mc_interface_mc_timer_isr() -> //重要函数：执行电机的定时器任务：把上面的计算结果应用到电机的控制（？）
                            //控制闪灯频率
                            //检测过压、欠压次数是否大于等于8
                            //执行可能需要的pwm周期后处理函数pwn_done_func()（默认为空）
                            const float current = mc_interface_get_tot_current_filtered(); //获取iq滤波值：带符号，表示拉电流或灌电流；用于求多次平均
                            const float current_in = mc_interface_get_tot_current_in_filtered(); //获取电源输入电流i_bus：正数为耗电、负数为充电；用于求多次平均
                       		abs_current = mcpwm_foc_get_abs_motor_current(); //获取电机电流幅值i_abs：包括id和iq
                    		abs_current_filtered = mcpwm_foc_get_abs_motor_current_filtered(); //获取电机电流幅值滤波值i_abs_filtered：包括id和iq
                            if (m_conf.l_slow_abs_current) {...} //根据l_slow_abs_current选择电机电流的瞬时值/滤波值作为电机过流的判断条件
                            const float f_samp = mc_interface_get_sampling_frequency_now(); //获取采样频率：等于开关频率foc_f_sw的1/2（？）

                            //收到上位机下发的“需要采集数据”命令时：
                            //每进入m_sample_int次会触发一次采集；
                            //每采集m_sample_len次会发送一次信号量通知当前线程；
                            ...
                            m_last_adc_duration_sample = mcpwm_get_last_adc_isr_duration(); //记录上一次的adc转换耗时（？）

                        last_inj_adc_isr_duration = (float) TIM12->CNT / 10000000.0; //统计该函数的执行时间：单位：秒（？）

0314：
1、下次要做的事：
（1）解决keil工程跑飞的问题：预计16小时；
a.keil工程的cstarup.s使用了ChibiOS官方给旧版ARM编译器RVCT写的文件（E:\cwq_Code\3_guangyi\VESC\ChibiOS_3.0.2\os\common\ports\ARMCMx\compilers\RVCT\cstartup.s）；
b.VESC的makefile调用写给GCC ARM编译器的.s文件，所以要对应GCC的来看怎么改为给ARMCC使用（？）：
    - *.s文件的语法内容在这个文档：D:\gcc-arm-none-eabi-9-2020-q2-update-win32\share\doc\gcc-arm-none-eabi\pdf\as.pdf
    - 中文参考资料：https://www.huaweicloud.com/articles/c22cfc440a163a12f9afe8125da503c5.html
（2）尝试keil自带的rtos调试工具：（EventRecorder、SystemView/SystemAnalyzer）；
（3）不使用keil自带的rtos调试工具，则尝试创建ChibiosStudio工程，来调试代码：预计16小时；

0317：
1、GCC汇编学习：
（1）ldr/str：在寄存器和内存之间传递数值：ldr为“内存传到寄存器”，ltr为“寄存器传到内存”；
（2）mov：把寄存器的数值，或立即数传给寄存器，不能实现内存和寄存器之间的互传；
（3）.type：对已定义的符号进行声明其类型；如.type Reset_Handler, %function表示“把Reset_Handler补充声明为一个汇编函数”；
（4）b：无条件跳转（b=branch，分支到本地标签local label）；可以后接其他字母以表示跳转条件，如bcc=“无进位跳转”，bcs=“有进位跳转”；
（5）定义函数：.section .text.<function>；
（6）定义变量：16bit的data段：.word <var>；
（7）